{"version":3,"file":"selectors.js","names":["_rstSelectorParser","require","_object","_interopRequireDefault","_arrayPrototype","_objectIs","_hasown","_byConstructor","_RSTTraversal","_Utils","_getAdapter","e","__esModule","_typeof","o","Symbol","iterator","constructor","prototype","_slicedToArray","r","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","l","t","n","i","u","a","f","call","next","Object","done","push","value","length","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","_arrayLikeToArray","toString","slice","name","from","test","parser","createParser","CHILD","ADJACENT_SIBLING","GENERAL_SIBLING","DESCENDANT","SELECTOR","TYPE_SELECTOR","CLASS_SELECTOR","ID_SELECTOR","UNIVERSAL_SELECTOR","ATTRIBUTE_PRESENCE","ATTRIBUTE_VALUE","PSEUDO_CLASS","PSEUDO_ELEMENT","EXACT_ATTRIBUTE_OPERATOR","WHITELIST_ATTRIBUTE_OPERATOR","HYPHENATED_ATTRIBUTE_OPERATOR","PREFIX_ATTRIBUTE_OPERATOR","SUFFIX_ATTRIBUTE_OPERATOR","SUBSTRING_ATTRIBUTE_OPERATOR","unique","arr","Set","uniqueReduce","fn","nodes","reduce","safelyGenerateTokens","selector","parse","err","Error","concat","matchAttributeSelector","node","token","operator","nodeProps","propsOfNode","descriptor","getOwnPropertyDescriptor","get","nodePropValue","type","hasOwn","is","split","indexOf","startsWith","matchPseudoSelector","root","parameters","every","reduceTreeBySelector","treeFilter","_findParentNode","findParentNode","rendered","_rendered","firstChild","_findParentNode2","document","adapter","getAdapter","activeElement","nodeToHostNode","nodeMatchesToken","hasClassName","nodeHasType","nodeHasId","buildPredicateFromToken","body","bodyToken","isComplexSelector","tokens","some","buildPredicate","isElementType","isValidElementType","matchesElementType","keys","hasUndefinedValues","values","nodeMatchesObjectProps","matchAdjacentSiblings","predicate","matches","parent","parentChildren","childrenOfNode","nodeIndex","adjacentSibling","matchGeneralSibling","youngerSiblings","filter","matchDirectChild","matchDescendant","flat","map","elements","elementsByConstructor","x","tag","results","index","reduceTreesBySelector","roots"],"sources":["../src/selectors.js"],"sourcesContent":["import { createParser } from 'rst-selector-parser';\nimport values from 'object.values';\nimport flat from 'array.prototype.flat';\nimport is from 'object-is';\nimport hasOwn from 'hasown';\nimport elementsByConstructor from 'html-element-map/byConstructor';\nimport {\n  treeFilter,\n  nodeHasId,\n  findParentNode,\n  nodeMatchesObjectProps,\n  childrenOfNode,\n  hasClassName,\n} from './RSTTraversal';\nimport { nodeHasType, propsOfNode } from './Utils';\nimport getAdapter from './getAdapter';\n// our CSS selector parser instance\nconst parser = createParser();\n\n// Combinators that allow you to chance selectors\nconst CHILD = 'childCombinator';\nconst ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nconst GENERAL_SIBLING = 'generalSiblingCombinator';\nconst DESCENDANT = 'descendantCombinator';\n\n// Selectors for targeting elements\nconst SELECTOR = 'selector';\nconst TYPE_SELECTOR = 'typeSelector';\nconst CLASS_SELECTOR = 'classSelector';\nconst ID_SELECTOR = 'idSelector';\nconst UNIVERSAL_SELECTOR = 'universalSelector';\nconst ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nconst ATTRIBUTE_VALUE = 'attributeValueSelector';\n// @TODO we dont support these, throw if they are used\nconst PSEUDO_CLASS = 'pseudoClassSelector';\nconst PSEUDO_ELEMENT = 'pseudoElementSelector';\n\nconst EXACT_ATTRIBUTE_OPERATOR = '=';\nconst WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nconst HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nconst PREFIX_ATTRIBUTE_OPERATOR = '^=';\nconst SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nconst SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\nfunction unique(arr) {\n  return [...new Set(arr)];\n}\n\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\nfunction uniqueReduce(fn, nodes) {\n  return unique(nodes.reduce(fn, []));\n}\n\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error(`Failed to parse selector: ${selector}`);\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  const { operator, value, name } = token;\n  const nodeProps = propsOfNode(node);\n  const descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n  const nodePropValue = nodeProps[name];\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return hasOwn(nodeProps, token.name);\n  }\n  // Only the exact value operator (\"=\") can match non-strings\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return is(nodePropValue, value);\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(`${value}-`);\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n    default:\n      throw new Error(`Enzyme::Selector: Unknown attribute selector operator \"${operator}\"`);\n  }\n}\n\nfunction matchPseudoSelector(node, token, root) {\n  const { name, parameters } = token;\n  if (name === 'not') {\n    // eslint-disable-next-line no-use-before-define\n    return parameters.every((selector) => reduceTreeBySelector(selector, node).length === 0);\n  }\n  if (name === 'empty') {\n    return treeFilter(node, (n) => n !== node).length === 0;\n  }\n  if (name === 'first-child') {\n    const { rendered } = findParentNode(root, node);\n    const [firstChild] = rendered;\n    return firstChild === node;\n  }\n  if (name === 'last-child') {\n    const { rendered } = findParentNode(root, node);\n    return rendered[rendered.length - 1] === node;\n  }\n  if (name === 'focus') {\n    if (typeof document === 'undefined') {\n      throw new Error('Enzyme::Selector does not support the \":focus\" pseudo-element without a global `document`.');\n    }\n    const adapter = getAdapter();\n    /* eslint-env browser */\n    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;\n  }\n\n  throw new TypeError(`Enzyme::Selector does not support the \"${token.name}\" pseudo-element or pseudo-class selectors.`);\n}\n\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\nfunction nodeMatchesToken(node, token, root) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n  switch (token.type) {\n    /**\n     * Match every node\n     * @example '*' matches every node\n     */\n    case UNIVERSAL_SELECTOR:\n      return true;\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n    case CLASS_SELECTOR:\n      return hasClassName(node, token.name);\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n    case TYPE_SELECTOR:\n      return nodeHasType(node, token.name);\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n    case ID_SELECTOR:\n      return nodeHasId(node, token.name);\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      return matchPseudoSelector(node, token, root);\n    default:\n      throw new Error(`Unknown token type: ${token.type}`);\n  }\n}\n\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\nfunction buildPredicateFromToken(token, root) {\n  return (node) => token.body.every((bodyToken) => nodeMatchesToken(node, bodyToken, root));\n}\n\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\nfunction isComplexSelector(tokens) {\n  return tokens.some((token) => token.type !== SELECTOR);\n}\n\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {EnzymeSelector} selector\n */\nexport function buildPredicate(selector) {\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    }\n    // Simple selectors only have a single selector token\n    return buildPredicateFromToken(tokens[0]);\n  }\n\n  // If the selector is an element type, check if the node's type matches\n  const adapter = getAdapter();\n  const isElementType = adapter.isValidElementType\n    ? adapter.isValidElementType(selector)\n    : typeof selector === 'function';\n  if (isElementType) {\n    return (node) => adapter.matchesElementType(node, selector);\n  }\n  // If the selector is an non-empty object, treat the keys/values as props\n  if (typeof selector === 'object') {\n    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {\n      const hasUndefinedValues = values(selector).some((value) => typeof value === 'undefined');\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n      return (node) => nodeMatchesObjectProps(node, selector);\n    }\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n\n  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');\n}\n\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    // If there's no parent, there's no siblings\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const adjacentSibling = parentChildren[nodeIndex + 1];\n    // No sibling\n    if (!adjacentSibling) {\n      return matches;\n    }\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n    return matches;\n  }, []);\n}\n\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const youngerSiblings = parentChildren.slice(nodeIndex + 1);\n    return matches.concat(youngerSiblings.filter(predicate));\n  }, nodes);\n}\n\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(childrenOfNode(node).filter(predicate)),\n    nodes,\n  );\n}\n\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(treeFilter(node, predicate)),\n    flat(nodes.map(childrenOfNode)),\n  );\n}\n\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n *\n * @param {EnzymeSelector} selector\n * @param {RSTNode} root\n */\nexport function reduceTreeBySelector(selector, root) {\n  if (typeof selector !== 'string') {\n    const elements = elementsByConstructor(selector);\n    if (elements.length > 0) {\n      return flat(elements.map((x) => reduceTreeBySelector(x.tag, root)));\n\n      // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved\n      // const htmlTagNames = elements.map(x => x.tag).join(', ');\n      // return reduceTreeBySelector(htmlTagNames, root);\n    }\n  }\n\n  if (typeof selector === 'function' || typeof selector === 'object') {\n    return treeFilter(root, buildPredicate(selector));\n  }\n\n  let results = [];\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    let index = 0;\n    while (index < tokens.length) {\n      const token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can traverse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjacent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n      if (token.type === SELECTOR) {\n        const predicate = buildPredicateFromToken(token, root);\n        results = results.concat(treeFilter(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        const { type } = token;\n        // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n        index += 1;\n        const predicate = buildPredicateFromToken(tokens[index], root);\n        // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, predicate, root);\n            break;\n          // The ~ combinator\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, predicate, root);\n            break;\n          // The > combinator\n          case CHILD:\n            results = matchDirectChild(results, predicate);\n            break;\n          // The ' ' (whitespace) combinator\n          case DESCENDANT: {\n            results = matchDescendant(results, predicate);\n            break;\n          }\n          default:\n            throw new Error(`Unknown combinator selector: ${type}`);\n        }\n      }\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n  return results;\n}\n\nexport function reduceTreesBySelector(selector, roots) {\n  const results = roots.map((n) => reduceTreeBySelector(selector, n));\n  return unique(flat(results, 1));\n}\n"],"mappings":"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","ignoreList":[]}